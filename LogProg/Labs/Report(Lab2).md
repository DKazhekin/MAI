#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Кажекин Д. А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Существует множество подходов к решению логических задач. Вот наиболее используюемые из них: метод рассуждений, метод таблиц, метод графов, метод блок-схем, метод бильярда, метод кругов Эйлера.

Пролог оказывается очень удобным для решения логических задач, так как его особенностью является возможность перебора всех вариантов-комбинаций с наложением на них соотвествующих условий. Программисту не нужно задумываться о том, как хранить данные, какие структуры данных использовать, потому что пролог, в отличиие от императивных языков программирования, работает с фактами и правилами. Это позволяет нам сосредоточиться только на логическом решении поставленной задачи.

## Задание

Один из пяти братьев разбил окно. Андрей сказал: Это или Витя, или Толя. Витя сказал: Это сделал не я и не Юра. Дима сказал: Нет, один из них сказал правду, а другой неправду. Юра сказал: Нет, Дима ты не прав. Их отец, которому, конечно можно доверять, уверен, что не менее трех братьев сказали правду. Кто разбил окно?

## Принцип решения

Для начала нам необходимо формализовать высказывания ребят. Я реализовал это с помощью предиката say(X,Y) при помощи стандартных средств логики в Прологе: операторов ".", ",", "not" (где X - имя говорящего, а Y - имя обвиняемого).

```prolog
says("Andrey", X):-
    X = "Vitya"; X = "Tolya".

says("Vitya", X):-
    X \= "Vitya", X \= "Yura".

says("Dima", X):-
    (says("Andrey", X), not(says("Vitya", X)));
    (says("Vitya", X), not(says("Andrey", X))).

says("Yura", X):-
    not(says("Dima", X)).
```

Далее я реализовал предикат true(X, Y), который получает на место X список людей, дававших показания, и возвращает на место Y виновника на основе всех показаний, если все они правдивы.

```prolog
true([],_).
true([H|T], X):-
        says(H, X), true(T, X).
```

Следующий предикат будет выводить нам финальный ответ. По сути, предыдущий предикат true(X,Y) уже дает нам информацию о виновнике, но кто-то из ребят солгал, поэтому, чтобы true(X,Y) выдавал нам правильный ответ, нам необходимо удалить из списка людей, дававших показания, лжеца. Найдем лжеца перебором (предикатом member(Liar, X), где X - список говоривших). Тогда true(X,Y), перебрав все возможные варианты, даст нам ответ. (Не забываем, что Толя молчал, поэтому в списке говоривших его не будет).

```prolog
solve(Answer):-
    member(Liar, ["Andrey", "Vitya", "Dima", "Yura"]),
    delete(["Andrey", "Vitya", "Dima", "Yura"], Liar, Final),
    true(Final, Answer), !.
```
## Выводы

Выполнив данную лабораторную работу, мне удалось подытожить пройденный материал, укрепить навыки написания Пролог-программ и умение работы со списками. Единственная проблема, с которой я столкнулся - это организация хода решения задачи, но в конечном итоге я смог это сделать, и полученная программа выдает верный, надеюсь, ответ.

Удивительным показался тот факт, что логические задачи на прологе решаются лаконично и как бы ни тафтологично это не звучало "логично"! Всего в несколько строк можно решить такую интересную задачу методом перебора, хоть это и не совсем оптимально с точки зрения скорости. 
