# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент:  Кажекин Д.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки в прологе явлются связными, а именно - односвязными (то есть каждый узел содержит лишь одну ссылку). Список в прологе очень похож на массивы, которые мы можем встретить в императивных языках программмирования, но отличительной чертой является то, что нам необязательно заранее указывать его размер (там их может быть сколько угодно), а также дешевизна доступа к первому элементу, что нельзя сказать о доступе к N-му элементу, так как нам придется совершить N переходов по ссылкам (Доступ к N-му элементу осуществляется не через итератор, а рекурсией). Пролог представляет списки в формате "[Голова|Хвост]". Немаловажной особоенностью является то, что в прологе нет операции присваивания, это происходит путем сопоставления с константами в фактах или правилах. Также интерес вызывает анонимная переменная, которой никогда не присваивается значение, пролог понимает, что нам не интересны данные на месте этой переменной. А бэктрекингом, как технологией, которая является основой для решения задач, составляющей дерево обхода, не может похвастаться любой другой массовый язык программирования.

## Задание 1.1: Предикат обработки списка

Стандартные предикаты обработки списка:


```prolog
% length() function

length([],0).
length([H|T], N):- length([T,T1], N1), N = N1 + 1.

% member() function

member([X|_],X).
member([_|T], X):-
member(T,X).

% append() function

append([], X, X).
append([H|T], X, [H|X2]):- append(T,X,X2).

% remove() function

del(Y,[Y], []).
del(X, [X|LIST1], LIST1).
del(X, [Y|LIST], [Y|LIST1]):- del(X,LIST,LIST1).

% permutation() function

permutation([],[]).
permutation(L,[X|P]):- del(X,L,L1), permutation(L1,P).

% sublist() function

sublist([],[]). 
sublist(S,L):-append(_,L1,L),append(S,_,L1).

```

```include(List, X, N, R)``` - предикат вставляет элемент 'X' в список 'List' на указанную позицию 'N' (Первый вариант реализации)

```insert(Y,O_List, Number, N_List)``` - (Второй вариант реализации)

Примеры использования (Первый вариант реализации):
```prolog
?- include([1,2,3,4], 5, 2, Res).
Res = [1, 5, 2, 3, 4] ;
?- include([1,2,3,4], Res, 2, [1,5,2,3,4]).
Res = 5 ;
?- include(Res, 5, 2, [1,5,2,3,4]).
Res = [1, 2, 3, 4] ;
```
Примеры использования (Второй вариант реализации):
```prolog
?- insert(2, [1,2,3,4], 3, Res).
Res = [1, 2, 2, 3, 4];
?- insert(Res, [1,2,3,4], 3, [1,2,2,3,4]).
Res = 2;
?- insert(2, Res, 2, [1,2,2,3,4]).
Res = [1, 2, 3, 4];
```

Реализация первым способом:

```prolog

include(List, X, 1, [X|List]).	
include([L1|L0], X, N, R):-
	Nn is N-1,
	include(L0, X, Nn, R0),
	R = [L1|R0].
  
```
Реализация вторым способом:

```prolog

insert(Y,O_List, Number, N_List):-		
	remove(Y, N_List, Number, O_List).

remove(Y, [Y|List1], 1, List1).
remove(Y, [B|List2], Number,[B|List1]):-
	Nn is Number - 1,
	remove(Y,List2, Nn,List1).
  
```

Принцип работы предиката первой реализации:

  1. Сначала обрабатываем случай, когда вставляем элемент на первое место (голову) - 'include(List, X, 1, [X|List])'.
  2. Далее проходимся рекурсивно по хвосту списка, уменьшая на каждой итерации N (место на которое мы должны вставить элемент), чтобы, дойдя до единицы, сработало правило из пункта 1).

Принцип работы предиката второй реализации: 

  1. Здесь мы используем стандартный предикат remove() и с его помощью определяем вставку, как обратное действие к удалению.
  2. Определяем удаление элемента с первого места (при Number = 1) и далее также рекурсивно проходимся по хвосту, не забывая уменьшать Number на 1 на каждой итерации.

## Задание 1.2: Предикат обработки числового списка

```indexOf(List, Index)``` - предикат вычисляет позицию 'Index' первого отрицательного элемента в списке

Примеры использования :

```prolog
?- indexOf([1,2,3,-1,5,2,4,-1], Index).
Index = 4.
?- indexOf([1,2,3,5,2,4,-1], Index).
Index = 7.
```

Реализация:

```prolog
indexOf([Element|_], 1):- 
	Element < 0.
indexOf([_|Tail], Index):-
  indexOf(Tail, Index1),
  !,
  Index is Index1+1.
```

Принцип работы предиката:

 1. Проверяем голову списка на отрицательность числа, стоящего там, следовательно индекс будет равен единице.
 2. Дальше рекурсивно идем по хвосту, рассматривая его голову на отрицательность, прибавляя к индексу единицу
 3. Не стоит забывать, что нам не нужен бэктрэкинг в этой задаче, он может привести к возвращению индекса к единице, поэтому исользуем cut символ '!'.


Содержательный пример совместного использования предикатов, реализованных в пунктах 3 и 4. (Предикат append() и include()):

```unity(List, X, N, Res)``` - предикат добавляет в конец списка и на указанную позицию, указанный пользователем, элемент.

Примеры использовния 

```prolog
?- ans([1,2,3], [2], 1, X).
X = [[2], 1, 2, 3, 2] ;
?- ans([1,2,3], [2,3], 1, X).
X = [[2, 3], 1, 2, 3, 2, 3] ;
?- ans([1,2,3], [2,3], 3, X).
X = [1, 2, [2, 3], 3, 2, 3] ;
```
Реализация:

```prolog
append([], X, X).
append([H|T], X, R):- 
	append(T,X,X2),
	R = [H|X2].

include(List, X, 1, [X|List]).
include([L1|L0], X, N, R):-
	Nn is N-1,
	include(L0, X, Nn, R0),
	R = [L1|R0].


unity(List, X, N, Res) :-
	append(List, X, R),
	include(R, X, N, Res).
```

Принцип работы предиката: 

1. Тривиальная работа программы, просто по указанным данным выполняются сначала один, а затем другой предикат, получаем ответ.

## Задание 2: Реляционное представление данных

К преимуществам реляционного представления данных можно смело отнести простоту и наглядность, что облегчает понимание и, в конце концов, работу с данными в таком виде. В общем и целом, из недостатков можно выделить медленный доступ к данным и большое количество памяти, необходимое для такого представления.
Всё вышесказанное относится и к представлению, с которым работал я в своём варианте задания (two.pl).

Прицип реализации предикатов из первого задания (Вариант 1):

1. Предикат, вычисляющий среднее арифметическое число по заданному наперёд списку:

```prolog

avg( List, Avg ):-
    sumlist( List, Sum ),
    length( List, Length),
    (  Length > 0
    -> Avg is Sum / Length
    ;  Avg is 0
    ).
    
```

Пример использования:

```
?- avg([1,2,3,4], X).
X = 2.5.
```

Принцип работы предиката:

Тривиальные действия в этом предикате: просто считается сумма списка, его длина, и вычисляется среднее арифметическое делением суммы на длину.

2. Предикат, показывающий группу и средний балл учеников по каждой из групп: 

```prolog

group_n_score(Group, [Group|Avg]):-						
	findall(X, grade(Group,_,_,X), X),
	avg(X, Avg).
	
answer1() :-
    group_n_score(101,X),
    group_n_score(102,Y),
    group_n_score(103,Z),
    group_n_score(104,W),
    write(X), nl, write(Y), nl, write(Z), nl, write(W), fail.

```

Пример использования:

```
?- group_n_score(102, X).
X = [102|3.7037037037037037].

?- consult("~/Desktop/two2.pl").
true.

?- group_n_score(101, X).
X = [101|4.033333333333333].

?- group_n_score(102, X).
X = [102|3.7037037037037037].

?- group_n_score(103, X).
X = [103|4.020833333333333].

?- group_n_score(104, X).
X = [104|3.9444444444444446].

?- answer1().
[101|4.033333333333333]
[102|3.7037037037037037]
[103|4.020833333333333]
[104|3.9444444444444446]
```

Принцип работы предиката:

1. По заданной группе с помощью сборщика всех решений findall() собираеам данные об оценках учеников одной группы и считаем среднее арифметическое по предикату avg().

3. Предикат, который выводит список студентов, не сдавших экзамен по какому-то предмету:

```prolog

failed_4_each_subject(Subject, Result):-									
	findall(Y, (grade(_,Y,Subject,Mark), Mark=2), Result).
	
answer2() :-
    failed_4_each_subject('Психология', X),
    failed_4_each_subject('Английский язык', Y),
    failed_4_each_subject('Информатика', Z),
    failed_4_each_subject('Функциональное программирование', W),
    failed_4_each_subject('Математический анализ', F),
    failed_4_each_subject('Логическое программирование', G),
    write(X), nl, write(Y), nl,write(Z), nl,write(W),
    nl, write(F), nl, write(G), nl,
    fail.
```

Пример использования:

```
?- failed_4_each_subject('Функциональное программирование', Result).
Result = ['Эфиркина'].

?- failed_4_each_subject('Логическое программирование', Result).
Result = ['Сидоров', 'Блокчейнис'].

?- failed_4_each_subject('Математический анализ', Result).
Result = ['Петров', 'Петровский', 'Сиплюсплюсов'].

?- failed_4_each_subject('Информатика', Result).
Result = ['Сиплюсплюсов', 'Текстописов'].

?- answer2().
[Психология,Ивановский]
[Английский язык,Круглосчиталкин,Эксель,Текстописова,Круглотличников]
[Информатика,Сиплюсплюсов,Текстописов]
[Функциональное программирование,Эфиркина]
[Математический анализ,Петров,Петровский,Сиплюсплюсов]
[Логическое программирование,Сидоров,Блокчейнис]
```

Принцип работы предиката:

1. Также используем сборщик решений findall() и как раз пригождается возможность ввести условие на отбор решений (Mark = 2), чтобы отобрать учеников, у которых за экзамен оценка - 2.

4. Предикат, находящий количество не сдавших студентов в каждой из групп:

```prolog

failed_4_each_group(G, List):-									
	findall(Student, (grade(G, Student,_, M), M=2), Student),
	length(Student, List).
	
answer3() :-
    failed_4_each_group(101, X),
    failed_4_each_group(102, Y),
    failed_4_each_group(103, Z),
    failed_4_each_group(104, W),
    write(X), nl, write(Y), nl,
    write(Z), nl, write(W), nl,
    fail.
```

Пример использования:
```
?- failed_4_each_group(101, List).
List = 2.

?- failed_4_each_group(102, List).
List = 5.

?- failed_4_each_group(103, List).
List = 4.

?- failed_4_each_group(104, List).
List = 2.

?- answer3().
[101|2]
[102|5]
[103|4]
[104|2]
```

Принцип работы предиката:

1. Используем идею предыдущего предиката за исключением дополнения в лице предиката length(), подсчитывающего сколько же человек не сдало экзамен.

## Выводы

Лабораторная работа показалась мне очень интересной и увлекательной. Мне удалось подробно разобраться в синтаксисе логического языка программирования Prolog и освоить стандартные предикаты обработки списков, изучить дополнительные материалы и применить свои знания на практике, решив ряд задач. Я понял особенности языка Prolog и посмотрел на программирование сквозь логическую парадигму. В ходе выполнения лабораторной работы возникли некоторые проблемы с написанием предикатов обработки списков, в частности рекурсивный обход хвоста списка, но я разобрался с этим вопросом и понял материал.
