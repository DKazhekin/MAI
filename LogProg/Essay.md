# Реферат
## по курсу "Логическое программирование"

### студент: Кажекин Д.А.

## Современные языки и системы логического программирования

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |


# Введение

  Еще в 1940-х годах профессор фон Нейман заложил основы, на которых разработаны все современные компьютеры. Если коротко углубиться в устройство машины фон Неймана, то она состоит из памяти и процессора с оперативной памятью, ячейки которой называются регистрами. Процессор загружает данные из памяти на регистры, после чего он может произвести различные арифметические, а также логические операции и сохранить результат обратно в память. Эта идея лежит в каждом современном цифровом устройстве. Но время не стояло на месте и люди стали интересоваться вопросом написания программ, которые могут быть исполнены компьютером, что повлекло за собой проблему выбора языка программирования.
	С течением времени языков стало появляться все больше и больше, причем они уже имели разную специфику написанию программ. Таким образом, сегодня мы имеем отдельные парадигмы программирования, основными являются: императивное программирование, декларативное программирование, структурное программирование, функциональное программирование, объектно-ориентированное программирование и, наконец-то, логическое программирование.
	Логическое программирование - парадигма программирования, а также раздел дискретной математики изучающий методы и возможности этой парадигмы, основанная на выводе новых фактов из данных фактов согласно заданным логическим правилам. Логическое программирование возникло как упрощение функционального программирования для математиков и лингвистов, решающих задачи символьной обработки. Вместо описания алгоритма решения задачи описывается мир задачи, какие имеются объекты, их свойства и отношения между ними. За основу описания берутся отношения между объектами. Логическая программа представляет собой набор отношений, которые называются фактами, и правил, на основании которых могут быть получены новые отношения. Она не задает никакого процесса вычислений.
	Если углубиться в историю, то первым языком логического программирования был Planner — функционально-логический язык программирования, схожий по своему синтаксису с Лиспом. Разработан в Лаборатории искусственного интеллекта Массачусетского технологического института Карлом Хьюттом в 1967—1971 годы, первая публикация с описанием языка появилась в 1969 году. Но самым революционным, конечно же, стало появление Prolog’a, который является самым популярным языком логического программирования - упрощением Planner’а. Поговорим о нём подробнее в следующем разделе.
 
 # Cовременные языки логического программирования
 
 ## Prolog
 
  Prolog означает программирование (Pro) в логике (Log), это декларативный язык, что означает, что программа состоит из данных, основанных на фактах (предикат, который возвращает значение True, если мы, например, скажем - “Марк сын Андрея” ) и правилах (логических отношениях), а не на конкретном алгоритме исчисления ответа.  Чтобы получить решение, пользователь задает вопрос, а не запускает программу, после чего выполняется поиск в базе данных фактов и правил. Пролог — это декларативный язык, что означает, что мы можем указать, какую проблему мы хотим решить, а не как ее решить. Пролог используется в некоторых областях, таких как базы данных, обработка естественного языка, искусственный интеллект, но он совершенно бесполезен в таких вещах как числовые вычисления. Реализацией искусственного интеллекта могут быть автоматизированные системы рассуждений, интерфейсы на естественном языке. Идентификаторы с заглавными буквами обозначают переменные. Идентификаторы, начинающиеся со строчных букв, обозначают значения данных. Основные элементы Пролога не имеют типов. Большинство реализаций пролога были расширены за счет включения целочисленных значений, символов и операций. Списки ( [ Head | Tail ] ) в прологе имеют большой вес в написании программ, они очень удобны. Интересным является принцип прохода по списку, который осуществляется рекурсивно (по хвосту).  Выполнение программы на Прологе эквивалентно поиску в дереве возможностей и определению объектов, удовлетворяющих заданным правилам. Пролог имеет отличный механизм бэктрекинга, поэтому при исследовании дерева он всегда может вернуться к другой ветке, если текущая ветвь не содержит ответа. Этот подход эквивалентен поиску в глубину, который известен как эффективный алгоритм обхода деревьев с большим количеством узлов. Принудительно в прологе можно реализовать и поиск в ширину, и с итерационным углублением. Иногда ответов при поиске в дереве может быть несколько, все это потому, что программа не завершается после нахождения первого решения, а идет до тех пор, пока все возможные варианты в дереве не проверены. Пролог имеет очень компактный, короткий и точный синтаксис, что упрощает кодирование. С точки зрения разработки сложность программирования на Прологе заключается только в расплывчатости человеческого мышления.
 
## Mercury
  
  Mercury — это язык функционального логического программирования, созданный для использования в решении реальных задач. Первая версия была разработана в Мельбурнском университете на факультете компьютерных наук Фергусом Хендерсоном, Томасом Конвеем и Золтаном Шомоджи под руководством Шомоджи и выпущена 8 апреля 1995 года. Mercury - чисто декларативный язык логического программирования. Это связано как с Prolog, так и с Haskell. Он имеет сильную, статическую, полиморфную систему типов. Синтаксически Mercury похож на Prolog с дополнениями, отчасти потому, что синтаксис Prolog является стандартным в сообществе логического программирования, а отчасти потому, что это упростило выполнение программ Mercury с использованием систем Prolog в процессе создания Mercury.
Однако семантически Mercury сильно отличается от Prolog. Mercury — это чисто логический язык программирования с четко определенной декларативной семантикой. Mercury предоставляет декларативные замены не логическим функциям Пролога. Mecrcury не сохраняет никаких не логических черт ( даже ввод-вывод является декларативным ). Этот язык программирования предназначен как минимум для двух групп программистов: Одна группа состоит из тех, кто имеет опыт работы с императивными языками, такими как C, и ищет язык более высокого уровня и более выразительный. Другая группа — это люди, имеющие опыт работы с языками логического программирования, такими как Prolog, которые ищут действительно декларативный язык, поддерживающий создание эффективных и надежных программных решений для больших и сложных задач. Кстати, компилятор Mercury написан на самом Mercury. Он был загружен с использованием NU-Prolog и SICStus Prolog. Компилятор Mercury компилирует программы Mercury в язык C, который используется в качестве переносимого ассемблера. Система может использовать некоторые расширения GNU C для языка C, если они доступны: возможность объявлять глобальные регистровые переменные, возможность принимать адреса меток и возможность использовать встроенный ассемблер. Используя эти расширения, он генерирует код, который значительно лучше, чем все предыдущие известные нам системы Prolog. Однако система не нуждается в этих расширениях и будет работать при их отсутствии.

## Oz

  Разработка Oz началась в 1991 году в DFKI1 под руководством Герта Смолки. Цель состояла в том, чтобы развить идеи программирования с ограничениями и параллельной логикой и разработать практически полезную систему программирования. В 1994 году группа пришла к финальному базовому языку и стабильной реализации (FDKI Oz).
Первоначальная вычислительная модель Oz 1 поддерживала детальное понятие параллелизма, при котором каждый оператор мог выполняться одновременно; опыт показал, что это было трудно отлаживать и неудобно в некоторых аспектах. Вместо этого Oz 2 использует модель параллелизма на основе потоков с явным созданием потоков. Oz 3 расширяет возможности Oz 2 за счет поддержки добавочного построения программ и синхронизации через Интернет.  Oz является “multi-paradigm” языком. Кто-то хотел бы изучить несколько парадигм, чтобы расширить свою культуру, но ему приходится сталкиваться со многими языками, такими как Java для объектно-ориентированного, Haskell для функционального, Erlang для параллелизма, Prolog и т. д. Изучение нового языка для каждой новой парадигмы подразумевает изменение синтаксиса, изменение семантики и среды. Таким образом, возможность сохранить один и тот же язык для нескольких парадигм — весьма важный выигрыш во времени. Теоретически это работает и в промышленности: когда язык демонстрирует ограничения своей парадигмы, возможно, придется использовать другой язык и связать их. Но если бы мы могли оставаться на одном языке, мы могли бы повысить производительность. Эту проблему и решает Oz. В наши дни было бы удивительно, если бы новый язык появился без какого-либо влияния. В случае Oz дизайн и реализация были взяты из AKL, что означает Andorra Kernel Language. Это параллельный язык ограничений с инкапсулированным поиском, разработанный в 90-х годах, с парадигмами программирования Prolog и GHC; существуют средства структурировать поиск «лучше», чем исходный поиск с возвратом в Прологе. AKL основан на экземпляре KAP (Kernel Andorra Prolog), разработанном теми же авторами. KAP определяется как язык логического программирования, основанный на ограничениях; он разработан таким образом, что Prolog, GHC, Parlog и Atomic Herbrand могут быть экземпляром KAP. Эта вычислительная модель была создана для обеспечения высокой степени распараллеливания. Особенностью является то, что в Oz мы не можем модифицировать переменные в ходе работы программы, нам доступно лишь повторное декларирование. Oz — язык с динамической типизацией: когда вводится переменная, ее тип и значение неизвестны; когда переменная связана со значением, определяется ее тип.

 ## Datalog
 
  Datalog — это язык декларативного логического программирования. Хотя синтаксически это подмножество Prolog, Datalog обычно использует восходящую, а не нисходящую модель оценки. Это отличие приводит к значительному отличию поведения и свойств от Пролога. Он часто используется в качестве языка запросов для дедуктивных баз данных. В последние годы Datalog нашел новое применение в интеграции данных, извлечении информации, создании сетей, анализе программ, безопасности, облачных вычислениях и машинном обучении. Его истоки восходят к началу логического программирования, но оно стало выделяться как отдельная область примерно в 1977 году, когда Эрве Галлер и Джек Минкер организовали семинар по логике и базам данных. Дэвиду Майеру приписывают введение термина Datalog. В отличие от Пролога, операторы программы Datalog могут быть указаны в любом порядке. Более того, запросы Datalog к конечным множествам гарантированно завершатся, поэтому в Datalog нет оператора cut в Прологе. Это делает Datalog полностью декларативным языком. В отличие от Пролога, Datalog запрещает сложные термины в качестве аргументов предикатов, например, p(1, 2) допустимо, но не p f(1), 2), накладывает определенные ограничения на использование отрицания и рекурсии, требует, чтобы каждая переменная, появляющаяся в отрицательном представлении в теле предложения, также появлялась в некотором положительном представлении в теле предложения. Однако Datalog не является полным по Тьюрингу и, таким образом, используется в качестве предметно-ориентированного языка, который может использовать преимущества эффективных алгоритмов, разработанных для разрешения запросов. Действительно, для эффективного выполнения запросов были предложены различные методы, например, алгоритм Magic Sets, табличное логическое программирование или разрешение SLG. Некоторые широко используемые системы баз данных включают идеи и алгоритмы, разработанные для Datalog. Например, стандарт SQL:1999 включает рекурсивные запросы, а алгоритм Magic Sets (первоначально разработанный для более быстрой оценки запросов Datalog) реализован в IBM DB2. Кроме того, механизмы Datalog стоят за специализированными системами баз данных, такими как база данных Intellidimension для семантической сети. В Datalog было внесено несколько расширений, например, для поддержки агрегатных функций, для обеспечения объектно-ориентированного программирования или для разрешения дизъюнкций в качестве заголовков предложений. Эти расширения оказывают существенное влияние на определение семантики Datalog и на реализацию соответствующего интерпретатора Datalog. Программа Datalog также, как и Prolog программа, состоит из списка фактов и правил (предложения Хорна).
 
## Fril

Fril — это язык программирования для исчисления предикатов первого порядка. Он включает семантику Пролога как подмножество, но берет свой синтаксис из микро-PROLOG и добавляет поддержку нечетких множеств, поддержку логики и метапрограммирования. Первоначально Fril был разработан Тревором Мартином и Джимом Болдуином в Бристольском университете примерно в 1980 году. В 1986 году его подхватила и доработала компания Equipu A.I. Research, которая позже стала Fril Systems Ltd. Название Fril изначально было аббревиатурой от Fuzzy Relational Inference Language. Базовые типы в Fril аналогичны типам в Прологе, за одним важным исключением: составной тип данных Пролога — это терм, а списки определяются как вложенные термы, тогда как в Fril составной тип — это сам список, который формирует основу для большинства конструкций. Переменные отличаются идентификаторами, содержащими только прописные буквы и знаки подчеркивания (тогда как Prolog требует, чтобы только первый символ был в верхнем регистре). Как и в Прологе, имя _ зарезервировано для обозначения «любого значения». В общем и целом синтаксис Fril’а схож с синтаксисом Lisp’а.  Например, что касается правил:
```fril
(fact)
(conclusion goal_1 ... goal_n)
```
Что очень похоже на прологовскую реализацию:
```prolog
fact.
conclusion :- goal_1, ..., goal_n.
```
Вместо дизъюнктивного символа “;” во Fril’e предусмотрен встроенный предикат “orr”. Некоторые данные могут быть представлены в виде отношений. Отношение эквивалентно набору фактов с тем же именем предиката и постоянной арностью, за исключением того, что ни один из фактов не может быть удален. Отношение записывается буквально как список, состоящий из имени предиката, за которым следует один или несколько кортежей отношения:
```prolog
(my-less-than
    (2 3)
    (8 23)
    (42 69))
```
Вместо: 
```prolog
((my-less-than 2 3))
((my-less-than 8 23))
((my-less-than 42 69))
```
Предикат может быть вызван ровно с одним аргументом, используя синтаксис:
```prolog
predicate argument
```
А запросы, также как и в прологе с помощью символа "?"

# Системы логического программирования

Просто наличия языка программирования совсем недостаточно для решения прикладных задач. Где писать код? Для этого существуют различные средства разработки-системы программирования, включающие в себя сразу несколько вещей: компилятор или интерпретатор, среду разработки, отладчик, справочную службу и т. д. 
О самых популярных логических системах программирования речь пойдет ниже.

## SWI-Prolog

  SWI-Prolog — это универсальная реализация языка Пролог. Хотя SWI-Prolog завоевал свою популярность в первую очередь в сфере образования, его развитие в основном обусловлено потребностями разработки приложений. Этому способствует богатый интерфейс, поддерживающий множество типов документов и (сетевых) протоколов, а также всеобъемлющий низкоуровневый интерфейс с C, который является основой для высокоуровневых интерфейсов с C++, Java (в комплекте), C#. , Python, Rust и т. д. (доступно извне). Расширения типов данных, такие как словари и строки, а также полная поддержка Unicode и неограниченных целых чисел упрощают беспрепятственный обмен данными с другими компонентами. SWI-Prolog нацелен на масштабируемость. Надежная поддержка многопоточности позволяет эффективно использовать многоядерное оборудование и упрощает встраивание в параллельные приложения. Его система Just In Time Indexing (JITI) обеспечивает прозрачную и эффективную поддержку предикатов с миллионами предложений. SWI-Prolog объединяет многие расширения основного языка, которые были разработаны в сообществе Prolog, такие как таблицы, ограничения, глобальные переменные, деструктивное присваивание, продолжения с разделителями и интеракторы. SWI-Prolog предлагает множество инструментов разработки, большинство из которых можно комбинировать по желанию. Родная система предоставляет редактор, написанный на Прологе, который является близким клоном Emacs. Он обеспечивает семантическое выделение, основанное на анализе кода в реальном времени самой системой Prolog. Дополнительные инструменты включают графический отладчик, профилировщик, анализ покрытия и перекрестные ссылки. Кроме того, есть режим для GNU-Emacs и плагин Eclipse, называемый PDT, и плагин VSC, каждый из которых можно комбинировать с собственными графическими инструментами. Наконец, SWISH предоставляет вычислительную записную книжку и веб-среду IDE. SWISH — это универсальный инструмент, который можно настраивать и расширять для различных сценариев. SWI-Prolog предоставляет дополнительный механизм распространения и установки, называемый пакетами. Пакет представляет собой каталог с минимальными организационными соглашениями и управляющим файлом, в котором описывается происхождение, версия, зависимости и поддержка автоматического обновления. Пакеты можно установить из архива, репозитория GIT или URL-адреса с помощью package_install/1. Пакеты используются для обмена кодом в сообществе. Система пакетов выросла из нескольких экосистем для работы с типами, сопрограммами и т. д.

## Melbourne Mercury Compiler

  Реализация языка программирования Mercury. Официальный (и единственный) компилятор Mercury. Транслирует код на Mercury в код на C. Написан на самом Mercury (бутстрепинг с NU-Prolog и SICStus Prolog). Официальная реализация Melbourne Mercury Compiler доступна для большинства Unix и Unix-подобных платформ, включая Linux , macOS и для Windows.
  
## Mozart Programming System

Система программирования Mozart сочетает в себе текущие исследования в области разработки и реализации языков программирования, программирования логики ограничений, распределенных вычислений и человеко-компьютерных интерфейсов. Mozart поддерживает компиляцию языка Oz и обеспечивает как выразительную мощь, так и расширенную функциональность. Компилятор Моцарта, в принципе, представляет собой лишь особый вид вычислителя. В общем, оценщик реализует отображение:
исходный_текст | среда -> значение. Выполнение оценки программ Oz с помощью компилятора имеет некоторые преимущества: программы со статически обнаруживаемыми ошибками отклоняются. Помимо синтаксических ошибок и необъявленных переменных, это также включает нерекомендуемое использование языка, которое, строго говоря, не обязательно является ошибкой. Например, применение процедуры с неправильным числом аргументов вызывает перехватываемое исключение, но о нем может быть сообщено как об ошибке. Программы могут быть переведены в более эффективное представление. В случае компилятора Mozart это байт-код для виртуальной машины Mozart.

## Strawberry Prolog

Strawberry Prolog разработан Институтом математики и информатики Болгарской академии наук. Первая версия была выпущена в 1996 году. Лидером команды Strawberry является Димитр Добрев. Strawberry Prolog — это диалект языка программирования Prolog. Его синтаксис очень близок к ISO-Prolog, но имеет много расширений, не являющихся частью стандарта. Основная идея Strawberry Prolog состоит в том, чтобы быть очень простым в использовании, поэтому некоторые университеты используют его для своих курсов Prolog. Некоторые расширения: глобальные переменные, массивы, определение функций и встроенных предикатов. пролог CGI-скрипты (позволяющих разрабатывать простые игры), ОLE-автоматизация — COM и ActiveX, Strawberry Prolog как сервер OLE, базы данных через ODBC. 

## Visual Prolog

Visual Prolog — мультипарадигмальный язык программирования, основанный на логическом языке Prolog. Цель Visual Prolog состоит в том, чтобы облегчить программные решения сложных проблем, связанных со знаниями. Visual Prolog — это мощный и типобезопасный язык программирования высокого уровня, последовательно и элегантно сочетающий в себе самые лучшие черты парадигм логического, функционального и объектно-ориентированного программирования. С помощью Visual Prolog вы можете создавать приложения для платформ Microsoft Windows 32/64. Он поддерживает расширенные клиент-серверные и трехуровневые решения. Visual Prolog особенно хорошо подходит для работы со сложными знаниями. Используя мощную объектную систему, вы можете очень жестко спроектировать приложение и в то же время извлечь выгоду из очень слабой связанности. Это позволит вам сократить расходы на разработку и еще больше на техническое обслуживание. Visual Prolog 8 — новейшее поколение языка логического программирования Visual Prolog, который можно использовать для создания приложений промышленного уровня для платформы Microsoft Windows. Это строго типизированный объектно-ориентированный язык программирования, основанный на языке программирования Prolog. Компилятор Visual Prolog является преемником компилятора Turbo Prolog, созданного в 1980-х годах, который был первым компилятором Prolog. С тех пор Центр разработки Prolog разрабатывает и совершенствует свой компилятор. В настоящее время компилятор Visual Prolog является мощным и эффективным компилятором. Среда разработки Visual Prolog содержит встроенный графический отладчик. Интегрированная среда разработки Visual Prolog (IDE) предназначена для того, чтобы сделать разработку, тестирование и изменение приложений, написанных на Visual Prolog, простой, удобной и быстрой. Это может быть особенно полезно при разработке крупных проектов.

## Заключение

В заключение хочется сказать, что логическое программирование занимает скорее всего “нишевую” область в мире разработки. Очень редко может пригодиться знание логического языка, часто можно найти альтернативу и решить проблему в другой парадигме, но только если это не переборка вариантов, рассуждения или простая задача искусственного интеллекта, где логическое программирование очень пригождается! Логическое программирование, по моему мнению, все же необходимо изучать, потому что оно хорошо развивает мышление и расширяет кругозор в сфере разработки. Всегда полезно посмотреть на вещи с другой стороны, парадигмы. Несамостоятельность логических языков подчеркивается тем фактом, что невозможно на них создавать комплексные программы, все равно приходится прибегать к языкам процедурных типов. По моему мнению, самым перспективным направлением в наше время является искусственный интеллект, который  в корни меняет устои общества, облегчая нашу жизнь. Лично у меня такое ощущение, что в будущем в сфере логического программирования могут ожидаться серьезные преобразования, раскрывающие потенциал решения задач искусственного интеллекта, но, пока что, это только фантазии.

## Список используемых источников

1. Сошников Д.В. Парадигма логического программирования
2. https://www.visual-prolog.com/features.htm
3. https://handwiki.org/wiki/Strawberry_Prolog
4. http://mozart2.org
5. http://progopedia.com/implementation/melbourne-mercury-compiler/
6. https://www.swi-prolog.org/features.html
7. Братко И. Программирование на языке Пролог для искусственного интеллекта
