# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Кажекин Денис Андрееивч

## Результат проверки

Вариант задания:

 - [ ] стандартный, без NLP (на 3)
 - [ ] стандартный, с NLP (на 3-4)
 - [x] продвинутый (на 3-5)
 
| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Задача моего курсового проекта состоит в создании диалоговой системы Eliza. В конечном итоге я получу опыт в программировании с применением технологии искусственого интеллекта, так как Элиза, основываясь на данных в ее словаре, автоматически дает конечному пользователю овтеты на естественном языке.

## Задание

Один из ранних успехов в области искусственного интеллекта был связан с созданием системы поддержания диалога на естественном языке ELIZA. Требуется реализовать такую систему на языке логического программирования Prolog.

## Принцип решения

Сперва необходимо было реализовать предикат (eliza\0), после вызова которого начинала работу наша программа и запускался бы цикл, в котором и происходило бы общение пользователя с Элизой.

```prolog
% Запускаем цикл Элизы
eliza :-
    write("Hello, what's up ? Talk to me.."), nl,
    eliza_loop.
```
Реализация цикла (eliza_loop\0) очень проста: сначала выводится отладочная печать, чтобы пользователь понимал, что он вступил в разговор с Элизой, а затем считываются введенные данные пользователя и с их использванием вызывается предикат (respond\1), который я объясню чуть ниже.

```prolog
% Сам цикл Элизы (чтение ввода и вызов предиката, определяющего формат вывода)
eliza_loop :-
    write('Eliza --> '),
    read(Input), respond(Input).
```

(respond\1) Отвечает за обработку входных данных от пользователя. Чтобы Элиза давала "осмысленные" ответы на запросы, необходимо прописать, что именно ей нужно печатать и в каких случаях. Ниже приведен разбор случая, когда пользователь вводит какую-нибудь команду из разряда "закончить программу". Если хоть одно слово из списка встретится в сообщении, то это будет значить, что Элизе необходимо попрощаться с пользователем и не продложать цикл (eliza_loop\0).

```prolog
respond(Input) :-
    member(Word, Input),
    member(Word, [quit, leave, bye, exit]),
    write('Nice to meet you, bye-bye'), nl.
```

В отличие от предиката выше, все следующие будут в конце вызывать продолжение цикла, потому что на них программа заканчиваться не должна.
Каждый из следующих предкатов (respond\1) следит за тем, какие слова встречаются в реплике ползователя и в соотвествии с этим выдает наиболее разумный ответ.

```prolog
respond([_,my,name,is, Name | _]) :-
    write('Hello,'), write(Name), write('! Pleased to meet you!'), nl,
    eliza_loop.

respond(Input) :-
    member(Word1, Input),
    member(Word1, [ hate, dislike ]),
    member(Word2, Input),
    member(Word2, [ you ]),
    write("Noo, of course it's false! :("), nl,
    eliza_loop.

respond(Input) :-
    member(Animal, Input),
    member(Animal, [dog, cat, fish, hamster, gerbil, snake, tortoise]),
    write("Hmm... Tell me more about pretty "),
    write(Animal), nl,
    eliza_loop.

respond(Input) :-
    member(Word, Input),
    member(Word, [upset, tired, confused, broken]),
    member(Word1, Input),
    member(Word1, [ i ]),
    write("To not to be "),
    write(Word),
    write(" just get distracted and relax a bit"), 
    nl,
    eliza_loop.

respond([how,are,you]) :-
    write("Yea I am fine, thanks, and you ?"), 
    nl,
    eliza_loop.

respond(Input) :-
    member(Word, Input),
    member(Word, [happy, joyful, fine]),
    write(Word),
    write("! Good mood is very important in business"), 
    nl,
    eliza_loop.

respond(Input) :-
    member(Word1, Input),
    member(Word1, [ think, suppose, tell]),
    member(Word2, Input),
    member(Word2, [ you, me ]),
    write("I do not know what to "),
    write(Word1),
    write(" the better way is to apply to your circle"), nl,
    eliza_loop.

respond(Input) :-
    member(Word, Input),
    member(Word, [what]),
    member(Word1, Input),
    member(Word1, [name]),
    write("My favourite name is Eliza"),
    nl,
    eliza_loop.
```

Если Элиза не знает что отвечать в конкретной ситуации, то реализован специальный динамический предикат (excuses\1), который содержит список ответов в таких ситуациях, причем они циклически меняются. Я поставил его в самый конец, чтобы безысходный ответ печатался только в случае, когда это действительно необходимо.

```prolog
% Динамический вывод разных ответов на неизвестные Элизе предложения
:- dynamic excuses/1.

excuses(["Okaay..", "I am good", "Hm..", "Let me think a bit..", "And what's next.."]).

% Ответы Элизы, , причем динамические, на непонятные ей высказывания

respond(_) :-
    retract(excuses([ Head | Tail ])),
    append(Tail, [ Head ], Newexcuses),
    asserta(excuses(Newexcuses)),
    write(Head),
    nl,
    eliza_loop.
```


## Выводы

При выполнении курсового проекта я столкнулся с непониманием, как реализовать непрерывное взаимодействие пользователя с программой, каким образом нужно выводить ответ в зависимости от содержания запроса. Это заставило изучить меня ряд зарубежной литературы, углубиться в разработку программм с применением искусственого интеллекта на Prolog и почерпнуть некоторые техники написания программ. В ходе работы, я полностью разобрался с принципом организации ИИ на логическом языке программирования и, как по мне, не зря выбрал задание с Элизой, потому что я освоил достаточно сложную тему в интересной, прикладной форме, составив чат-бота. Оказывается, что решение, такой серьезной задачи очень удобно и приятно оформляется на Prolog, не первый раз подтверждая силу логического програмиирования на ряде задач.
